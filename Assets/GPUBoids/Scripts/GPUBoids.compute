//#pragma kernel GenerateBoids
#pragma kernel UpdateBoids 


#define THREAD_GROUP_SIZE 512

#include "Assets/GPUBoids/Shaders/boidInclude.hlsl"



uint boidCount;

// Simulation Parameters;
float visualRangeSq;
float minDistanceSq;

float cohesionFactor;
float separationFactor;
float alignmentFactor;

float turnSpeed;
float deltaTime;

// Bounds
float xBound;
float yBound;
float zBound;
float maxSpeed;
float minSpeed;

uint gridDimX;
uint gridDimY;
uint gridDimZ;
float gridCellSize;


StructuredBuffer<uint> offsetBuffer;



// Random Boid Generation
/*
uint randSeed;
float rand(float min, float max, inout uint rngState) 
{
    rngState = rngState * 747796405u + 2891336453u;
    uint state = rngState;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    float f = ((word >> 22u) ^ word) / 4294967296.0;
    return f * (max - min) + min;
}


[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void GenerateBoids(uint3 id : SV_DispatchThreadID) 
{
    if (id.x >= boidCount) {return;}

    uint rngState = randSeed + id.x;
    boidsOut[id.x].position = float3(rand(-xBound, xBound, rngState), rand(-yBound, yBound, rngState), rand(-zBound, zBound, rngState));
    boidsOut[id.x].velocity = float3(rand(-maxSpeed, maxSpeed, rngState), rand(-maxSpeed, maxSpeed, rngState), rand(-maxSpeed, maxSpeed, rngState));
}
*/




// Boid Simulation
uint3 getGridLocation(BoidData boid) 
{
    int boidX = floor(boid.position.x / gridCellSize + gridDimX / 2);
    int boidY = floor(boid.position.y / gridCellSize + gridDimY / 2);
    int boidZ = floor(boid.position.z / gridCellSize + gridDimZ / 2);
    return uint3(boidX, boidY, boidZ);
}

uint getGridID(uint3 pos) 
{
    return (gridDimY * gridDimX * pos.z) + (gridDimX * pos.y) + pos.x;
}

void MergedBehaviours(inout BoidData boid) 
{
    float3 center = 0;
    float3 close = 0;
    float3 avgVel = 0;
    uint neighbours = 0;

    uint3 gridXYZ = getGridLocation(boid);
    uint cell = getGridID(gridXYZ);
    uint zStep = gridDimX * gridDimY;

    for (uint z = cell - zStep; z <= cell + zStep; z += zStep) 
    {
        for (uint y = z - gridDimX; y <= z + gridDimX; y += gridDimX) 
        {
            uint start = offsetBuffer[y - 2];
            uint end = offsetBuffer[y + 1];
            
            for (uint i = start; i < end; i++) 
            {
                BoidData other = boidsIn[i];
                float3 diff = boid.position - other.position;
                float distSq = dot(diff, diff);
                
                if (distSq > 0 && distSq < visualRangeSq) 
                {
                    if (distSq < minDistanceSq) 
                    {
                        close += diff / distSq;
                    }
                    center += other.position;
                    avgVel += other.velocity;
                    neighbours++;
                }
            }
        }
    }

    if (neighbours > 0) 
    {
        center /= neighbours;
        avgVel /= neighbours;

        boid.velocity += (center - boid.position) * (cohesionFactor * deltaTime);
        boid.velocity += (avgVel - boid.velocity) * (alignmentFactor * deltaTime);
    }

    boid.velocity += close * (separationFactor * deltaTime);
}

void LimitSpeed(inout BoidData boid) 
{
    float speed = length(boid.velocity);
    float clampedSpeed = clamp(speed, minSpeed, maxSpeed);
    boid.velocity *= clampedSpeed / speed;
}

void KeepInBounds(inout BoidData boid) 
{
    
    if (abs(boid.position.x) > xBound) 
    {
        //boid.velocity.x -= sign(boid.position.x) * deltaTime * turnSpeed;
        boid.velocity.x = -boid.velocity.x;
        boid.position.x = sign(boid.position.x) * xBound;
        //boid.position = float3(0,0,0);
    }
    if (abs(boid.position.y) > yBound) 
    {
        //boid.velocity.y -= sign(boid.position.y) * deltaTime * turnSpeed;
        boid.velocity.y = -boid.velocity.y;
        boid.position.y = sign(boid.position.y) * yBound;
        //boid.position = float3(0,0,0);
    }
    if (abs(boid.position.z) > zBound) 
    {
        //boid.velocity.z -= sign(boid.position.z) * deltaTime * turnSpeed;
        boid.velocity.z = -boid.velocity.z;
        boid.position.z = sign(boid.position.z) * zBound;
        //boid.position = float3(0,0,0);
    }

    /*
    if (abs(boid.position.x) > xBound || abs(boid.position.y) > yBound || abs(boid.position.z) > zBound)
    {
        boid.velocity -= normalize(boid.position) * deltaTime * turnSpeed;
    }*/
}


[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateBoids(uint3 id : SV_DispatchThreadID) 
{
    if (id.x >= boidCount) 
    {
        return;
    }
    
    BoidData boid = boidsIn[id.x];
    
    MergedBehaviours(boid);
    LimitSpeed(boid);

    // Update positions
    boid.position += boid.velocity * deltaTime;
    KeepInBounds(boid);

    boidsOut[id.x] = boid;
}

